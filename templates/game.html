<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Game ‚Äì Arena</title>
  <link rel="stylesheet"
    href="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.css" />
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { background: #f5f3ef; color: #333; font-family: 'Segoe UI', Noto Sans, sans-serif; }
    header { background: #fff; padding: 10px 24px; display: flex; align-items: center; gap: 14px; border-bottom: 1px solid #ccc; box-shadow: 0 1px 3px rgba(0,0,0,.06); }
    header h1 { color: #333; font-size: 1.2rem; }
    a { color: #629924; text-decoration: none; font-size: 0.9rem; }
    a:hover { text-decoration: underline; }
    .layout { display: flex; gap: 24px; padding: 20px; max-width: 900px; margin: 0 auto; flex-wrap: wrap; }
    .board-col { flex: 0 0 auto; }
    #board-wrap { position: relative; width: 480px; }
    #move-layer { position: absolute; inset: 0; width: 100%; height: 100%; pointer-events: none; z-index: 5; }
    .move-from { fill: rgba(255, 196, 64, 0.45); stroke: rgba(224, 148, 0, 0.85); stroke-width: 2; }
    .move-to { fill: rgba(255, 228, 128, 0.55); stroke: rgba(224, 148, 0, 0.95); stroke-width: 2; }
    #anno-layer { position: absolute; inset: 0; width: 100%; height: 100%; pointer-events: none; z-index: 6; }
    .anno-arrow { stroke: rgba(32, 104, 210, 0.9); stroke-width: 8; stroke-linecap: round; fill: none; }
    .anno-arrow.preview { stroke: rgba(32, 104, 210, 0.4); }
    .anno-dot { fill: rgba(32, 104, 210, 0.42); stroke: rgba(32, 104, 210, 0.85); stroke-width: 2; }
    .side-col { flex: 1; min-width: 220px; display: flex; flex-direction: column; gap: 14px; }
    .card { background: #fff; border: 1px solid #ddd; border-radius: 4px; padding: 14px; }
    .player-bar { display: flex; justify-content: space-between; align-items: center; padding: 10px 14px; border-radius: 4px; margin-bottom: 6px; background: #f5f5f5; border: 1px solid #e0e0e0; }
    .player-bar.active { background: #e8f5e9; border-color: #c8e6c9; }
    .player-name { font-weight: bold; font-size: 1rem; color: #333; }
    .clock { font-size: 1.5rem; font-weight: bold; font-variant-numeric: tabular-nums; color: #333; }
    .clock.low { color: #c62828; animation: pulse 1s infinite; }
    @keyframes pulse { 0%,100%{opacity:1} 50%{opacity:.5} }
    button { background: #759900; color: #fff; border: none; padding: 9px 16px; border-radius: 3px; cursor: pointer; font-size: 0.9rem; width: 100%; margin-bottom: 8px; font-weight: 600; }
    button:hover { background: #618200; }
    button.secondary { background: #eee; color: #333; border: 1px solid #ccc; }
    button.secondary:hover { background: #e0e0e0; }
    button:disabled { background: #e0e0e0; color: #aaa; cursor: default; }
    #status { font-size: 1rem; text-align: center; padding: 10px; border-radius: 4px; background: #f5f5f5; border: 1px solid #ddd; color: #333; }
    #status.won { background: #e8f5e9; color: #2e7d32; border-color: #c8e6c9; }
    #status.lost { background: #fce4ec; color: #c62828; border-color: #ffcdd2; }
    #status.draw { background: #f5f5f5; color: #777; border-color: #e0e0e0; }
    #moves { font-size: 0.82rem; color: #555; max-height: 120px; overflow-y: auto; word-break: break-all; line-height: 1.6; font-family: monospace; }
    #move-nav { display: none; gap: 8px; align-items: center; margin-bottom: 8px; }
    #move-nav button { width: auto; margin: 0; padding: 6px 10px; font-size: 0.78rem; }
    #move-nav-info { color: #666; font-size: 0.78rem; margin-left: auto; }
    .mv { display: inline-block; padding: 1px 4px; border-radius: 3px; cursor: pointer; }
    .mv:hover { background: #f3efe3; }
    .mv.active { background: #f7e4a6; color: #5f4400; }
    .mv em { color: #888; font-style: normal; font-size: 0.75rem; margin-left: 3px; }
    .berserk-btn { background: #6a1b9a; }
    .berserk-btn:hover { background: #4a0e72; }
    #return-btn { display: none; background: #629924; }
    #return-btn:hover { background: #518000; }
    #ping-bar {
      position: fixed; left: 14px; bottom: 14px;
      background: #fff; border: 1px solid #ccc;
      border-radius: 4px; padding: 8px 12px;
      font-size: 0.82rem; display: flex; align-items: center; gap: 8px;
      z-index: 20; box-shadow: 0 2px 6px rgba(0,0,0,.1); color: #333;
    }
    .ping-bars { display: flex; align-items: flex-end; gap: 2px; height: 12px; }
    .ping-bars span { width: 4px; background: #ccc; border-radius: 2px; }
    .ping-bars span:nth-child(1) { height: 4px; }
    .ping-bars span:nth-child(2) { height: 6px; }
    .ping-bars span:nth-child(3) { height: 9px; }
    .ping-bars span:nth-child(4) { height: 12px; }
    .ping-bars.good span { background: #759900; }
    .ping-bars.medium span:nth-child(-n+3) { background: #e07000; }
    .ping-bars.medium span:nth-child(4) { background: #ccc; }
    .ping-bars.bad span:nth-child(-n+2) { background: #c62828; }
    .ping-bars.bad span:nth-child(n+3) { background: #ccc; }
    .ping-bars.down span { background: #ccc; }

    /* Lichess CBurnett board colors override */
    .white-1e1d7 { background-color: #f0d9b5 !important; }
    .black-3c85d { background-color: #b58863 !important; }
  </style>
</head>
<body>
<header>
  <a href="/">‚Üê Home</a>
  <h1>‚ôü Live Game</h1>
  <span id="tc-label" style="color:#777;margin-left:auto;font-size:0.85rem;"></span>
</header>

<div class="layout">
  <div class="board-col">
    <div id="opponent-bar" class="player-bar">
        <span id="opponent-title" style="font-weight:bold;font-size:0.78rem;margin-right:3px;"></span>
        <span id="opponent-name" class="player-name">‚Äî</span>
        <span id="opponent-rating" class="player-rating" style="margin-left:8px;color:#555;">‚Äî</span>
        <span id="opponent-clock" class="clock">‚Äî:‚Äî‚Äî</span>
      </div>
      <div id="board-wrap">
        <div id="board" style="width:480px"></div>
        <svg id="move-layer"></svg>
        <svg id="anno-layer"></svg>
      </div>
      <div id="my-bar" class="player-bar">
        <span id="my-title" style="font-weight:bold;font-size:0.78rem;margin-right:3px;"></span>
        <span id="my-name" class="player-name">‚Äî</span>
        <span id="my-rating" class="player-rating" style="margin-left:8px;color:#555;">‚Äî</span>
        <span id="my-clock" class="clock">‚Äî:‚Äî‚Äî</span>
    </div>
  </div>

  <div class="side-col">
    <div id="status">Waiting for game data‚Ä¶</div>

	    <div class="card">
	      <button id="resign-btn" onclick="resign()">Resign</button>
	      <button class="berserk-btn" id="berserk-btn" onclick="berserk()">‚ö° Berserk</button>
	      <button class="secondary" id="claim-btn" onclick="claimTime()">Claim on time</button>
	      <button class="secondary" id="return-btn" onclick="window.history.back()">‚Üê Back</button>
	    </div>

    <div class="card">
      <div style="font-size:0.8rem;color:#777;margin-bottom:6px;">Move list</div>
      <div id="move-nav">
        <button class="secondary" id="prev-move-btn" title="Arrow Left">‚óÄ</button>
        <button class="secondary" id="next-move-btn" title="Arrow Right">‚ñ∂</button>
        <span id="move-nav-info"></span>
      </div>
      <div id="moves"></div>
    </div>
  </div>
</div>

<div id="ping-bar">
  <div id="ping-bars" class="ping-bars down"><span></span><span></span><span></span><span></span></div>
  <div id="ping-text">-- ms</div>
</div>

<script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
<script src="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>

	<script>
	  const GAME_ID = {{ game_id }};
	  const MY_ID   = {{ my_id }};
	  const SPECTATOR = {{ 'true' if spectator else 'false' }};
	  const TITLE_COLORS = {GM:'#f01010',IM:'#e07000',FM:'#c0a000',CM:'#8888aa',NM:'#999',WGM:'#e01080',WIM:'#e07000',WFM:'#c0a000',WCM:'#8888aa',BOT:'#4e94d4'};

  let game = new Chess();
  let board = null;
  let myColor = null;
  let gameOver = false;
  let whiteClockMs = 0;
  let blackClockMs = 0;
  let clockRunningFor = 'white';
  let lastSync = Date.now();
  let pollInterval = null;
  let clockInterval = null;
  let pingInterval = null;
  let allMoves = [];
  let moveTimesMs = [];
  let viewPly = null;
  let replayEndWhiteClockMs = 0;
  let replayEndBlackClockMs = 0;
  let replayIncrementMs = 2000;
  let pendingPremove = null;
  let premoveSubmitting = false;
  let rightDragStart = null;
  let rightDragPreview = null;
  const noteDots = new Set();
  const noteArrows = new Set();
  const FILES = 'abcdefgh';

  function setLoadingError(message) {
    const statusEl = document.getElementById('status');
    statusEl.textContent = message;
    statusEl.className = '';
  }

  function playerLabel(name, title, rating, rank) {
    const titlePart = title ? ` (${title})` : '';
    const ratingPart = (rating === null || rating === undefined) ? '' : ` (${rating})`;
    const rankPart = (rank === null || rank === undefined) ? '' : ` (#${rank})`;
    return `${name}${titlePart}${ratingPart}${rankPart}`;
  }

  function formatMoveTime(ms) {
    if (ms === null || ms === undefined || Number.isNaN(ms)) return '--';
    const n = Math.max(0, Number(ms));
    if (n <= 0) return '--';
    if (n < 1000) return `${(n / 1000).toFixed(1)}s`;
    const sec = Math.round(n / 100) / 10;
    if (sec < 60) return `${sec.toFixed(1)}s`;
    const m = Math.floor(sec / 60);
    const s = (sec % 60).toFixed(1).padStart(4, '0');
    return `${m}:${s}`;
  }

  function parseUci(uci) {
    if (!uci || uci.length < 4) return null;
    return { from: uci.slice(0, 2), to: uci.slice(2, 4), promotion: uci.length > 4 ? uci[4] : undefined };
  }

  function applyUci(boardObj, uci) {
    const p = parseUci(uci);
    if (!p) return null;
    return boardObj.move({ from: p.from, to: p.to, promotion: p.promotion });
  }

  function buildPositionAtPly(ply) {
    const b = new Chess();
    const clamped = Math.max(0, Math.min(ply, allMoves.length));
    for (let i = 0; i < clamped; i++) {
      if (!applyUci(b, allMoves[i])) break;
    }
    return b;
  }

  function clearUserAnnotations(shouldRender = true) {
    noteDots.clear();
    noteArrows.clear();
    rightDragStart = null;
    rightDragPreview = null;
    if (shouldRender) renderAnnotations();
  }

  function replayClocksAtPly(ply) {
    const clamped = Math.max(0, Math.min(Number(ply) || 0, allMoves.length));
    const inc = Math.max(0, Number(replayIncrementMs) || 0);
    let wc = Math.max(0, Number(replayEndWhiteClockMs) || 0);
    let bc = Math.max(0, Number(replayEndBlackClockMs) || 0);
    for (let i = allMoves.length - 1; i >= clamped; i--) {
      const spent = Math.max(0, Number(moveTimesMs[i]) || 0);
      if ((i % 2) === 0) {
        wc = Math.max(0, wc + spent - inc);
      } else {
        bc = Math.max(0, bc + spent - inc);
      }
    }
    return { white: wc, black: bc };
  }

  function myTurnNow() {
    return (game.turn() === 'w' && myColor === 'white') ||
           (game.turn() === 'b' && myColor === 'black');
  }

  function getBoardSurface() {
    return document.querySelector('#board .board-b72b1') || document.querySelector('#board [class*="board-"]');
  }

  function squareFromMouseEvent(evt) {
    const surface = getBoardSurface();
    if (!surface) return null;
    const rect = surface.getBoundingClientRect();
    const x = evt.clientX - rect.left;
    const y = evt.clientY - rect.top;
    if (x < 0 || y < 0 || x >= rect.width || y >= rect.height) return null;

    const size = rect.width / 8;
    const fileFromLeft = Math.floor(x / size);
    const rankFromTop = Math.floor(y / size);

    let fileIdx;
    let rankIdx;
    if (myColor === 'black') {
      fileIdx = 7 - fileFromLeft;
      rankIdx = rankFromTop;
    } else {
      fileIdx = fileFromLeft;
      rankIdx = 7 - rankFromTop;
    }
    return `${FILES[fileIdx]}${rankIdx + 1}`;
  }

  function squareCenter(square) {
    const surface = getBoardSurface();
    if (!surface || !square || square.length < 2) return null;
    const rect = surface.getBoundingClientRect();
    const size = rect.width / 8;

    const fileIdx = FILES.indexOf(square[0]);
    const rankIdx = Number(square[1]) - 1;
    if (fileIdx < 0 || rankIdx < 0 || rankIdx > 7) return null;

    let fileFromLeft;
    let rankFromTop;
    if (myColor === 'black') {
      fileFromLeft = 7 - fileIdx;
      rankFromTop = rankIdx;
    } else {
      fileFromLeft = fileIdx;
      rankFromTop = 7 - rankIdx;
    }

    return {
      x: (fileFromLeft + 0.5) * size,
      y: (rankFromTop + 0.5) * size,
      width: rect.width,
      height: rect.height,
    };
  }

  function squareBox(square) {
    const c = squareCenter(square);
    if (!c) return null;
    const size = c.width / 8;
    return { x: c.x - size / 2, y: c.y - size / 2, size, width: c.width, height: c.height };
  }

  function renderMoveHighlight() {
    const svg = document.getElementById('move-layer');
    const surface = getBoardSurface();
    if (!svg || !surface) return;
    const rect = surface.getBoundingClientRect();
    svg.setAttribute('viewBox', `0 0 ${rect.width} ${rect.height}`);
    svg.innerHTML = '';
    if (!allMoves.length || viewPly == null || viewPly <= 0) return;

    const mv = parseUci(allMoves[viewPly - 1]);
    if (!mv) return;
    const fromBox = squareBox(mv.from);
    const toBox = squareBox(mv.to);
    if (fromBox) {
      const r = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
      r.setAttribute('x', String(fromBox.x + 1.5));
      r.setAttribute('y', String(fromBox.y + 1.5));
      r.setAttribute('width', String(fromBox.size - 3));
      r.setAttribute('height', String(fromBox.size - 3));
      r.setAttribute('rx', '6');
      r.setAttribute('class', 'move-from');
      svg.appendChild(r);
    }
    if (toBox) {
      const r = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
      r.setAttribute('x', String(toBox.x + 1.5));
      r.setAttribute('y', String(toBox.y + 1.5));
      r.setAttribute('width', String(toBox.size - 3));
      r.setAttribute('height', String(toBox.size - 3));
      r.setAttribute('rx', '6');
      r.setAttribute('class', 'move-to');
      svg.appendChild(r);
    }
  }

  function renderMoveList() {
    const movesEl = document.getElementById('moves');
    if (!movesEl) return;
    if (!allMoves.length) {
      movesEl.textContent = '';
      return;
    }
    const bits = [];
    for (let i = 0; i < allMoves.length; i++) {
      if (i % 2 === 0) bits.push(`<span style="color:#777">${Math.floor(i / 2) + 1}.</span>`);
      const active = (viewPly === i + 1) ? ' active' : '';
      const t = formatMoveTime(moveTimesMs[i]);
      bits.push(`<span class="mv${active}" data-ply="${i + 1}">${allMoves[i]}<em>${t}</em></span>`);
    }
    movesEl.innerHTML = bits.join(' ');
  }

  function updateMoveNavigator() {
    const nav = document.getElementById('move-nav');
    const prev = document.getElementById('prev-move-btn');
    const next = document.getElementById('next-move-btn');
    const info = document.getElementById('move-nav-info');
    if (!nav || !prev || !next || !info) return;

    if (!gameOver || !allMoves.length) {
      nav.style.display = 'none';
      return;
    }

    nav.style.display = 'flex';
    const ply = viewPly == null ? allMoves.length : viewPly;
    prev.disabled = ply <= 0;
    next.disabled = ply >= allMoves.length;
    if (ply <= 0) {
      info.textContent = `Start position (${allMoves.length} moves)`;
    } else {
      info.textContent = `Move ${ply}/${allMoves.length} ‚Ä¢ ${formatMoveTime(moveTimesMs[ply - 1])}`;
    }
  }

  function setViewPly(ply) {
    const clamped = Math.max(0, Math.min(ply, allMoves.length));
    viewPly = clamped;
    if (gameOver) {
      const replay = replayClocksAtPly(viewPly);
      whiteClockMs = replay.white;
      blackClockMs = replay.black;
      clockRunningFor = null;
      lastSync = Date.now();
      game = buildPositionAtPly(viewPly);
      if (board) board.position(game.fen());
    }
    renderClocks();
    renderMoveList();
    updateMoveNavigator();
    renderMoveHighlight();
    renderAnnotations();
  }

  function stepView(delta) {
    if (!gameOver) return;
    const current = viewPly == null ? allMoves.length : viewPly;
    setViewPly(current + delta);
  }

  function installMoveNavigator() {
    const prev = document.getElementById('prev-move-btn');
    const next = document.getElementById('next-move-btn');
    const movesEl = document.getElementById('moves');
    if (prev) prev.addEventListener('click', () => stepView(-1));
    if (next) next.addEventListener('click', () => stepView(1));

    if (movesEl) {
      movesEl.addEventListener('click', (e) => {
        const el = e.target.closest('[data-ply]');
        if (!el || !gameOver) return;
        const ply = Number(el.getAttribute('data-ply') || '0');
        if (!Number.isFinite(ply)) return;
        setViewPly(ply);
      });
    }

    window.addEventListener('keydown', (e) => {
      if (!gameOver) return;
      const tag = (e.target && e.target.tagName) ? e.target.tagName.toLowerCase() : '';
      if (tag === 'input' || tag === 'textarea') return;
      if (e.key === 'ArrowLeft') {
        stepView(-1);
        e.preventDefault();
      } else if (e.key === 'ArrowRight') {
        stepView(1);
        e.preventDefault();
      }
    });
  }

  function renderAnnotations() {
    const svg = document.getElementById('anno-layer');
    const surface = getBoardSurface();
    if (!svg || !surface) return;
    const rect = surface.getBoundingClientRect();
    svg.setAttribute('viewBox', `0 0 ${rect.width} ${rect.height}`);
    svg.innerHTML = `
      <defs>
        <marker id="anno-arrow-head" viewBox="0 0 12 12" refX="10" refY="6" markerWidth="8" markerHeight="8" orient="auto-start-reverse">
          <path d="M 0 0 L 12 6 L 0 12 z" fill="rgba(32, 104, 210, 0.9)"></path>
        </marker>
      </defs>
    `;

    for (const key of noteArrows) {
      const from = key.slice(0, 2);
      const to = key.slice(2, 4);
      const a = squareCenter(from);
      const b = squareCenter(to);
      if (!a || !b) continue;
      const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
      line.setAttribute('x1', String(a.x));
      line.setAttribute('y1', String(a.y));
      line.setAttribute('x2', String(b.x));
      line.setAttribute('y2', String(b.y));
      line.setAttribute('class', 'anno-arrow');
      line.setAttribute('marker-end', 'url(#anno-arrow-head)');
      svg.appendChild(line);
    }

    if (rightDragStart && rightDragPreview && rightDragPreview !== rightDragStart) {
      const a = squareCenter(rightDragStart);
      const b = squareCenter(rightDragPreview);
      if (a && b) {
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('x1', String(a.x));
        line.setAttribute('y1', String(a.y));
        line.setAttribute('x2', String(b.x));
        line.setAttribute('y2', String(b.y));
        line.setAttribute('class', 'anno-arrow preview');
        line.setAttribute('marker-end', 'url(#anno-arrow-head)');
        svg.appendChild(line);
      }
    }

    for (const square of noteDots) {
      const c = squareCenter(square);
      if (!c) continue;
      const dot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
      dot.setAttribute('cx', String(c.x));
      dot.setAttribute('cy', String(c.y));
      dot.setAttribute('r', String((rect.width / 8) * 0.18));
      dot.setAttribute('class', 'anno-dot');
      svg.appendChild(dot);
    }
  }

  function installRightClickNotes() {
    const wrap = document.getElementById('board-wrap');
    if (!wrap) return;

    function isInsideWrap(evt) {
      const t = evt.target;
      return !!(t && (t === wrap || wrap.contains(t)));
    }

    // Disable native context menu on the board area (capture phase is more reliable).
    document.addEventListener('contextmenu', (e) => {
      if (isInsideWrap(e) || rightDragStart !== null) {
        e.preventDefault();
      }
    }, true);

    wrap.addEventListener('mousedown', (e) => {
      if (e.button !== 2) return;
      const sq = squareFromMouseEvent(e);
      if (!sq) return;
      rightDragStart = sq;
      rightDragPreview = sq;
      renderAnnotations();
      e.preventDefault();
    });

    window.addEventListener('mousemove', (e) => {
      if (rightDragStart == null) return;
      const sq = squareFromMouseEvent(e);
      rightDragPreview = sq || rightDragStart;
      renderAnnotations();
      e.preventDefault();
    });

    window.addEventListener('mouseup', (e) => {
      if (rightDragStart == null) return;
      const sq = squareFromMouseEvent(e);
      if (!sq) {
        rightDragStart = null;
        rightDragPreview = null;
        renderAnnotations();
        return;
      }

      if (sq === rightDragStart) {
        if (noteDots.has(sq)) {
          noteDots.delete(sq);
        } else {
          noteDots.add(sq);
        }
      } else {
        const key = `${rightDragStart}${sq}`;
        const reverse = `${sq}${rightDragStart}`;
        if (noteArrows.has(key)) {
          noteArrows.delete(key);
        } else if (noteArrows.has(reverse)) {
          noteArrows.delete(reverse);
        } else {
          noteArrows.add(key);
        }
      }
      rightDragStart = null;
      rightDragPreview = null;
      renderAnnotations();
      e.preventDefault();
    });

    window.addEventListener('blur', () => {
      if (rightDragStart == null) return;
      rightDragStart = null;
      rightDragPreview = null;
      renderAnnotations();
    });
  }

  async function maybeSubmitPremove() {
    if (SPECTATOR || gameOver || !pendingPremove || premoveSubmitting || !myTurnNow()) return;
    const promo = pendingPremove.promotion || '';
    const legal = game.moves({ verbose: true }).some((m) =>
      m.from === pendingPremove.from &&
      m.to === pendingPremove.to &&
      ((m.promotion || '') === promo)
    );
    if (!legal) {
      pendingPremove = null;
      return;
    }

    premoveSubmitting = true;
    try {
      const data = await api(`/api/games/${GAME_ID}/move`, 'POST', { move: pendingPremove.uci });
      pendingPremove = null;
      applyState(data);
    } catch (e) {
      pendingPremove = null;
      await poll();
    } finally {
      premoveSubmitting = false;
    }
  }

  async function api(url, method='GET', body=null) {
    const opts = { method, headers: {'Content-Type':'application/json'}, credentials:'same-origin' };
    if (body) opts.body = JSON.stringify(body);
    const r = await fetch(url, opts);
    let data = null;
    try {
      data = await r.json();
    } catch (e) {
      data = null;
    }
    if (!r.ok) {
      const msg = (data && (data.error || data.message)) ? (data.error || data.message) : `request failed (${r.status})`;
      throw new Error(msg);
    }
    return data || {};
  }

  function formatClock(ms) {
    if (ms <= 0) return '0:00';
    const total = Math.ceil(ms / 1000);
    const m = Math.floor(total / 60);
    const s = total % 60;
    return `${m}:${s.toString().padStart(2,'0')}`;
  }

  function renderClocks() {
    const now = Date.now();
    const elapsed = now - lastSync;
    let wc = whiteClockMs;
    let bc = blackClockMs;
    if (!gameOver) {
      if (clockRunningFor === 'white') wc = Math.max(0, wc - elapsed);
      else bc = Math.max(0, bc - elapsed);
    }

    const myIsWhite = myColor === 'white';
    const myClock   = myIsWhite ? wc : bc;
    const oppClock  = myIsWhite ? bc : wc;

    document.getElementById('my-clock').textContent = formatClock(myClock);
    document.getElementById('opponent-clock').textContent = formatClock(oppClock);

    const myEl  = document.getElementById('my-clock');
    const oppEl = document.getElementById('opponent-clock');
    myEl.className  = 'clock' + (myClock  < 10000 ? ' low' : '');
    oppEl.className = 'clock' + (oppClock < 10000 ? ' low' : '');
  }

	  function applyState(data) {
    const previousMoveCount = allMoves.length;
    whiteClockMs   = data.white_clock_ms;
    blackClockMs   = data.black_clock_ms;
    replayEndWhiteClockMs = Math.max(0, Number(data.white_clock_ms) || 0);
    replayEndBlackClockMs = Math.max(0, Number(data.black_clock_ms) || 0);
    clockRunningFor = data.clock_running_for;
    lastSync       = Date.now();
    replayIncrementMs = Math.max(0, Number(data.increment_ms) || 0);

    allMoves = (data.pgn_moves || '').split(' ').filter(Boolean);
    moveTimesMs = Array.isArray(data.move_times_ms_list) ? data.move_times_ms_list.map((v) => Math.max(0, Number(v) || 0)) : [];
    while (moveTimesMs.length < allMoves.length) moveTimesMs.push(0);
    if (moveTimesMs.length > allMoves.length) moveTimesMs = moveTimesMs.slice(0, allMoves.length);
    if (allMoves.length !== previousMoveCount) clearUserAnnotations(false);

    gameOver = data.result !== 'ongoing';
    if (!gameOver) {
      viewPly = allMoves.length;
      game.load(data.fen);
      if (board) board.position(data.fen);
    } else if (viewPly == null || viewPly > allMoves.length) {
      viewPly = allMoves.length;
    }

    const myIsWhite = myColor === 'white';
    document.getElementById('my-bar').className    = 'player-bar' + ((myIsWhite && data.clock_running_for==='white') || (!myIsWhite && data.clock_running_for==='black') ? ' active' : '');
    document.getElementById('opponent-bar').className = 'player-bar' + ((myIsWhite && data.clock_running_for==='black') || (!myIsWhite && data.clock_running_for==='white') ? ' active' : '');

	    const statusEl = document.getElementById('status');
	    if (gameOver) {
	      stopIntervals();
	      board.draggable = false;
	      document.getElementById('resign-btn').disabled = true;
	      document.getElementById('berserk-btn').disabled = true;
	      document.getElementById('claim-btn').disabled = true;
	      document.getElementById('return-btn').style.display = 'block';

	      if (data.result === 'draw') {
	        statusEl.textContent = 'Draw!'; statusEl.className = 'draw';
	      } else {
	        if (SPECTATOR) {
	          statusEl.textContent = `Game over: ${data.result === 'white' ? 'White' : 'Black'} wins.`;
	          statusEl.className = '';
	        } else {
	          const iWon = (data.result === 'white' && myColor === 'white') ||
	                       (data.result === 'black' && myColor === 'black');
	          statusEl.textContent = iWon ? 'üèÜ You won!' : 'You lost.';
	          statusEl.className   = iWon ? 'won' : 'lost';
	        }
	      }
	    } else {
	      if (SPECTATOR) {
	        statusEl.textContent = game.turn() === 'w' ? 'White to move' : 'Black to move';
	      } else {
	        const myTurn = myTurnNow();
          if (!myTurn && pendingPremove) {
            statusEl.textContent = `Opponent's turn (premove: ${pendingPremove.from}${pendingPremove.to})`;
          } else {
            statusEl.textContent = myTurn ? 'Your turn' : "Opponent's turn";
          }
	      }
	      statusEl.className   = '';
	    }

    if (gameOver) {
      setViewPly(viewPly);
    } else {
      renderClocks();
      renderMoveList();
      updateMoveNavigator();
      renderMoveHighlight();
      renderAnnotations();
      maybeSubmitPremove();
    }
  }

  async function poll() {
    if (gameOver) return;
    try {
      const data = await api(`/api/games/${GAME_ID}`);
      applyState(data);
    } catch (e) {
      setLoadingError(`Connection issue: ${e.message}`);
    }
  }

  function stopIntervals() {
    clearInterval(pollInterval);
    clearInterval(clockInterval);
    clearInterval(pingInterval);
  }

  function renderPing(ms, ok=true) {
    const text = document.getElementById('ping-text');
    const bars = document.getElementById('ping-bars');
    if (!ok || ms == null) {
      text.textContent = 'offline';
      bars.className = 'ping-bars down';
      return;
    }
    text.textContent = `${ms} ms`;
    if (ms < 120) bars.className = 'ping-bars good';
    else if (ms < 280) bars.className = 'ping-bars medium';
    else bars.className = 'ping-bars bad';
  }

  async function updatePing() {
    const start = performance.now();
    try {
      const r = await fetch('/api/ping', { credentials: 'same-origin', cache: 'no-store' });
      if (!r.ok) throw new Error();
      const ms = Math.round(performance.now() - start);
      renderPing(ms, true);
    } catch (e) {
      renderPing(null, false);
    }
  }

	  function onDragStart(source, piece) {
	    if (SPECTATOR) return false;
	    if (gameOver) return false;
	    if ((myColor === 'white' && piece.startsWith('b')) ||
	        (myColor === 'black' && piece.startsWith('w'))) return false;
	    return true;
	  }

	  async function onDrop(source, target) {
	    if (SPECTATOR) return 'snapback';
	    const promotion = 'q';
	    const fullUci = source + target + (isPromotion(source, target) ? promotion : '');
    const piece = game.get(source);
    if (!piece) return 'snapback';

    if (!myTurnNow()) {
      pendingPremove = { from: source, to: target, promotion, uci: fullUci };
      const statusEl = document.getElementById('status');
      statusEl.textContent = `Opponent's turn (premove: ${source}${target})`;
      statusEl.className = '';
      return 'snapback';
    }

    // optimistically apply move to local board for immediate visual feedback
    const move = game.move({ from: source, to: target, promotion });
    if (!move) {
      return 'snapback';
    }
    board.position(game.fen());
    clearUserAnnotations();

    // now validate and save server-side
    try {
      const data = await api(`/api/games/${GAME_ID}/move`, 'POST', { move: fullUci });
      applyState(data);
    } catch (e) {
      game.undo();
      board.position(game.fen());
      return 'snapback';
    }
  }

  function isPromotion(from, to) {
    const piece = game.get(from);
    if (!piece || piece.type !== 'p') return false;
    return (piece.color === 'w' && to[1] === '8') ||
           (piece.color === 'b' && to[1] === '1');
  }

  function onSnapEnd() {
    board.position(game.fen());
  }

  async function resign() {
    if (!confirm('Resign this game?')) return;
    await api(`/api/games/${GAME_ID}/resign`, 'POST');
    await poll();
  }

  async function berserk() {
    await api(`/api/games/${GAME_ID}/berserk`, 'POST');
    await poll();
  }

  async function claimTime() {
    const data = await api(`/api/games/${GAME_ID}/claim-time`, 'POST');
    if (data.ok) await poll();
    else setLoadingError(data.message || 'No opponent clock expired yet');
  }

	  async function init() {
      let data;
      try {
        data = await api(`/api/games/${GAME_ID}`);
      } catch (e) {
        setLoadingError(`Unable to load game: ${e.message}`);
        return;
      }
	    myColor = (!SPECTATOR && data.white_id === MY_ID) ? 'white' : 'black';
	    if (SPECTATOR) {
	      myColor = 'white';
	      document.getElementById('resign-btn').style.display = 'none';
	      document.getElementById('berserk-btn').style.display = 'none';
	      document.getElementById('claim-btn').style.display = 'none';
	    }

      const myIsWhite = myColor === 'white';
      const myLabel = myIsWhite
        ? playerLabel(data.white, data.white_title, data.white_rating, data.white_tournament_rank ?? data.white_rank)
        : playerLabel(data.black, data.black_title, data.black_rating, data.black_tournament_rank ?? data.black_rank);
      const oppLabel = myIsWhite
        ? playerLabel(data.black, data.black_title, data.black_rating, data.black_tournament_rank ?? data.black_rank)
        : playerLabel(data.white, data.white_title, data.white_rating, data.white_tournament_rank ?? data.white_rank);

      document.getElementById('my-name').textContent = myLabel;
      document.getElementById('opponent-name').textContent = oppLabel;
      document.getElementById('my-title').textContent = '';
      document.getElementById('opponent-title').textContent = '';
      document.getElementById('my-rating').textContent = '';
      document.getElementById('opponent-rating').textContent = '';
    board = Chessboard('board', {
	      draggable: !SPECTATOR,
	      position: data.fen,
	      orientation: myColor,
	      onDragStart,
	      onDrop,
      onSnapEnd,
      pieceTheme: function(piece) {
        return `https://lichess1.org/assets/piece/cburnett/${piece}.svg`;
      },
    });
    installRightClickNotes();
    installMoveNavigator();
    window.addEventListener('resize', () => {
      renderMoveHighlight();
      renderAnnotations();
    });

    applyState(data);

    if (data.result === 'ongoing') {
      // shorten poll interval so opponent moves show up more responsively,
      // the previous 1.5‚Äësecond delay made the UI feel sluggish.
      pollInterval  = setInterval(poll, 500);
      clockInterval = setInterval(renderClocks, 100);
    }
    updatePing();
    pingInterval = setInterval(updatePing, 5000);
  }

  init();
</script>
</body>
</html>
