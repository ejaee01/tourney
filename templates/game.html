<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Game ‚Äì Arena</title>
  <link rel="stylesheet"
    href="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.css" />
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { background: #1a1a2e; color: #e0e0e0; font-family: 'Segoe UI', sans-serif; }
    header { background: #16213e; padding: 14px 24px; display: flex; align-items: center; gap: 14px; border-bottom: 2px solid #0f3460; }
    header h1 { color: #e94560; font-size: 1.2rem; }
    a { color: #64b5f6; text-decoration: none; font-size: 0.9rem; }
    .layout { display: flex; gap: 24px; padding: 24px; max-width: 900px; margin: 0 auto; flex-wrap: wrap; }
    .board-col { flex: 0 0 auto; }
    .side-col { flex: 1; min-width: 220px; display: flex; flex-direction: column; gap: 16px; }
    .card { background: #16213e; border: 1px solid #0f3460; border-radius: 10px; padding: 16px; }
    .player-bar { display: flex; justify-content: space-between; align-items: center; padding: 10px 14px; border-radius: 8px; margin-bottom: 8px; background: #0f3460; }
    .player-bar.active { background: #1a4a8a; border: 1px solid #64b5f6; }
    .player-name { font-weight: bold; font-size: 1rem; }
    .clock { font-size: 1.5rem; font-weight: bold; font-variant-numeric: tabular-nums; color: #ffd700; }
    .clock.low { color: #e94560; animation: pulse 1s infinite; }
    @keyframes pulse { 0%,100%{opacity:1} 50%{opacity:.5} }
    button { background: #e94560; color: #fff; border: none; padding: 9px 16px; border-radius: 6px; cursor: pointer; font-size: 0.9rem; width: 100%; margin-bottom: 8px; }
    button:hover { background: #c73652; }
    button.secondary { background: #0f3460; }
    button.secondary:hover { background: #1a4a8a; }
    button:disabled { background: #333; cursor: default; }
    #status { font-size: 1rem; text-align: center; padding: 10px; border-radius: 6px; background: #0f3460; }
    #status.won { background: #1b3a1b; color: #81c784; }
    #status.lost { background: #3d1a1a; color: #ef9a9a; }
    #status.draw { background: #2a2a2a; color: #ccc; }
    #moves { font-size: 0.82rem; color: #aaa; max-height: 120px; overflow-y: auto; word-break: break-all; line-height: 1.6; }
    .berserk-btn { background: #6a1b9a; }
    .berserk-btn:hover { background: #4a0e72; }
    #return-btn { display: none; background: #1a4a8a; }
    #ping-bar { position: fixed; left: 14px; bottom: 14px; background: rgba(15,52,96,.92); border: 1px solid #1a4a8a; border-radius: 8px; padding: 8px 12px; font-size: 0.82rem; display: flex; align-items: center; gap: 8px; z-index: 20; }
    .ping-bars { display: flex; align-items: flex-end; gap: 2px; height: 12px; }
    .ping-bars span { width: 4px; background: #2d5a27; border-radius: 2px; opacity: .3; }
    .ping-bars span:nth-child(1) { height: 4px; }
    .ping-bars span:nth-child(2) { height: 6px; }
    .ping-bars span:nth-child(3) { height: 9px; }
    .ping-bars span:nth-child(4) { height: 12px; }
    .ping-bars.good span { background: #81c784; opacity: 1; }
    .ping-bars.medium span:nth-child(-n+3) { background: #ffd54f; opacity: 1; }
    .ping-bars.medium span:nth-child(4) { opacity: .2; }
    .ping-bars.bad span:nth-child(-n+2) { background: #ef9a9a; opacity: 1; }
    .ping-bars.bad span:nth-child(n+3) { opacity: .2; }
    .ping-bars.down span { background: #e94560; opacity: .25; }
  </style>
</head>
<body>
<header>
  <a href="/">‚Üê Home</a>
  <h1>‚ôü Live Game</h1>
  <span id="tc-label" style="color:#aaa;margin-left:auto;font-size:0.85rem;"></span>
</header>

<div class="layout">
  <div class="board-col">
    <div id="opponent-bar" class="player-bar">
      <span id="opponent-name" class="player-name">‚Äî</span>
      <span id="opponent-clock" class="clock">‚Äî:‚Äî‚Äî</span>
    </div>
    <div id="board" style="width:480px"></div>
    <div id="my-bar" class="player-bar">
      <span id="my-name" class="player-name">{{ my_username }}</span>
      <span id="my-clock" class="clock">‚Äî:‚Äî‚Äî</span>
    </div>
  </div>

  <div class="side-col">
    <div id="status">Waiting for game data‚Ä¶</div>

    <div class="card">
      <button id="resign-btn" onclick="resign()">Resign</button>
      <button class="berserk-btn" id="berserk-btn" onclick="berserk()">‚ö° Berserk</button>
      <button class="secondary" onclick="claimTime()">Claim on time</button>
      <button class="secondary" id="return-btn" onclick="window.history.back()">‚Üê Back to Tournament</button>
    </div>

    <div class="card">
      <div style="font-size:0.8rem;color:#aaa;margin-bottom:6px;">Move list</div>
      <div id="moves"></div>
    </div>
  </div>
</div>

<div id="ping-bar">
  <div id="ping-text">Ping: -- ms</div>
  <div id="ping-bars" class="ping-bars down"><span></span><span></span><span></span><span></span></div>
</div>

<script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
<script src="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>

<script>
  const GAME_ID = {{ game_id }};
  const MY_ID   = {{ my_id }};

  let game = new Chess();
  let board = null;
  let myColor = null;
  let gameOver = false;
  let whiteClockMs = 0;
  let blackClockMs = 0;
  let clockRunningFor = 'white';
  let lastSync = Date.now();
  let pollInterval = null;
  let clockInterval = null;
  let pingInterval = null;

  async function api(url, method='GET', body=null) {
    const opts = { method, headers: {'Content-Type':'application/json'}, credentials:'same-origin' };
    if (body) opts.body = JSON.stringify(body);
    const r = await fetch(url, opts);
    return r.json();
  }

  function formatClock(ms) {
    if (ms <= 0) return '0:00';
    const total = Math.ceil(ms / 1000);
    const m = Math.floor(total / 60);
    const s = total % 60;
    return `${m}:${s.toString().padStart(2,'0')}`;
  }

  function renderClocks() {
    const now = Date.now();
    const elapsed = now - lastSync;
    let wc = whiteClockMs;
    let bc = blackClockMs;
    if (!gameOver) {
      if (clockRunningFor === 'white') wc = Math.max(0, wc - elapsed);
      else bc = Math.max(0, bc - elapsed);
    }

    const myIsWhite = myColor === 'white';
    const myClock   = myIsWhite ? wc : bc;
    const oppClock  = myIsWhite ? bc : wc;

    document.getElementById('my-clock').textContent = formatClock(myClock);
    document.getElementById('opponent-clock').textContent = formatClock(oppClock);

    const myEl  = document.getElementById('my-clock');
    const oppEl = document.getElementById('opponent-clock');
    myEl.className  = 'clock' + (myClock  < 10000 ? ' low' : '');
    oppEl.className = 'clock' + (oppClock < 10000 ? ' low' : '');
  }

  function applyState(data) {
    whiteClockMs   = data.white_clock_ms;
    blackClockMs   = data.black_clock_ms;
    clockRunningFor = data.clock_running_for;
    lastSync       = Date.now();

    game.load(data.fen);
    if (board) board.position(data.fen);

    const moveList = (data.pgn_moves || '').split(' ').filter(Boolean);
    document.getElementById('moves').textContent = moveList.join(' ');

    const myIsWhite = myColor === 'white';
    document.getElementById('my-bar').className    = 'player-bar' + ((myIsWhite && data.clock_running_for==='white') || (!myIsWhite && data.clock_running_for==='black') ? ' active' : '');
    document.getElementById('opponent-bar').className = 'player-bar' + ((myIsWhite && data.clock_running_for==='black') || (!myIsWhite && data.clock_running_for==='white') ? ' active' : '');

    const statusEl = document.getElementById('status');
    if (data.result !== 'ongoing') {
      gameOver = true;
      stopIntervals();
      board.draggable = false;
      document.getElementById('resign-btn').disabled = true;
      document.getElementById('berserk-btn').disabled = true;
      document.getElementById('return-btn').style.display = 'block';

      if (data.result === 'draw') {
        statusEl.textContent = 'Draw!'; statusEl.className = 'draw';
      } else {
        const iWon = (data.result === 'white' && myColor === 'white') ||
                     (data.result === 'black' && myColor === 'black');
        statusEl.textContent = iWon ? 'üèÜ You won!' : 'You lost.';
        statusEl.className   = iWon ? 'won' : 'lost';
      }
    } else {
      const myTurn = (game.turn() === 'w' && myColor === 'white') ||
                     (game.turn() === 'b' && myColor === 'black');
      statusEl.textContent = myTurn ? 'Your turn' : "Opponent's turn";
      statusEl.className   = '';
    }

    renderClocks();
  }

  async function poll() {
    if (gameOver) return;
    const data = await api(`/api/games/${GAME_ID}`);
    applyState(data);
  }

  function stopIntervals() {
    clearInterval(pollInterval);
    clearInterval(clockInterval);
    clearInterval(pingInterval);
  }

  function renderPing(ms, ok=true) {
    const text = document.getElementById('ping-text');
    const bars = document.getElementById('ping-bars');
    if (!ok || ms == null) {
      text.textContent = 'Ping: offline';
      bars.className = 'ping-bars down';
      return;
    }
    text.textContent = `Ping: ${ms} ms`;
    if (ms < 120) bars.className = 'ping-bars good';
    else if (ms < 280) bars.className = 'ping-bars medium';
    else bars.className = 'ping-bars bad';
  }

  async function updatePing() {
    const start = performance.now();
    try {
      const r = await fetch('/api/me', { credentials: 'same-origin', cache: 'no-store' });
      if (!r.ok) throw new Error('ping failed');
      const ms = Math.round(performance.now() - start);
      renderPing(ms, true);
    } catch (e) {
      renderPing(null, false);
    }
  }

  function onDragStart(source, piece) {
    if (gameOver) return false;
    if ((myColor === 'white' && piece.startsWith('b')) ||
        (myColor === 'black' && piece.startsWith('w'))) return false;
    if ((game.turn() === 'w') !== (myColor === 'white')) return false;
    return true;
  }

  async function onDrop(source, target) {
    const uci = source + target;
    const promotion = 'q';
    const fullUci = source + target + (isPromotion(source, target) ? promotion : '');

    const data = await api(`/api/games/${GAME_ID}/move`, 'POST', { move: fullUci });
    if (data.error) {
      return 'snapback';
    }
    applyState(data);
  }

  function isPromotion(from, to) {
    const piece = game.get(from);
    if (!piece || piece.type !== 'p') return false;
    return (piece.color === 'w' && to[1] === '8') ||
           (piece.color === 'b' && to[1] === '1');
  }

  function onSnapEnd() {
    board.position(game.fen());
  }

  async function resign() {
    if (!confirm('Resign this game?')) return;
    const data = await api(`/api/games/${GAME_ID}/resign`, 'POST');
    await poll();
  }

  async function berserk() {
    await api(`/api/games/${GAME_ID}/berserk`, 'POST');
    await poll();
  }

  async function claimTime() {
    const data = await api(`/api/games/${GAME_ID}/claim-time`, 'POST');
    if (data.ok) await poll();
    else alert(data.message);
  }

  async function init() {
    const data = await api(`/api/games/${GAME_ID}`);
    myColor = data.white_id === MY_ID ? 'white' : 'black';

    document.getElementById('my-name').textContent       = myColor === 'white' ? data.white : data.black;
    document.getElementById('opponent-name').textContent = myColor === 'white' ? data.black : data.white;
    document.getElementById('tc-label').textContent      = `+${data.increment_ms/1000}s increment`;

    board = Chessboard('board', {
      draggable: true,
      position: data.fen,
      orientation: myColor,
      onDragStart,
      onDrop,
      onSnapEnd,
      pieceTheme: 'https://chessboardjs.com/img/chesspieces/wikipedia/{piece}.png',
    });

    applyState(data);

    if (data.result === 'ongoing') {
      pollInterval  = setInterval(poll, 1500);
      clockInterval = setInterval(renderClocks, 100);
    }
    updatePing();
    pingInterval = setInterval(updatePing, 5000);
  }

  init();
</script>
</body>
</html>
